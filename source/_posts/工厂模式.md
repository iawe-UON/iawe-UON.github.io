---
title: 工厂模式
date: 2026-01-27 23:42:35
tags: 设计模式
---

工厂模式简单来说就是将新对象的创建过程进行封装，只需要传递config进入工厂，就可以创建符合要求的目标对象。 本质上是不对外暴露对象的创建过程。是一种创建型的设计模式。

优点：（1）解耦（2）可维护（3）遵守开闭原则

<!--more-->

案例一：简单工厂模式

```python
from abc import ABC, abstractmethod

# 产品接口
class animal(ABC):
    @abstractmethod
    def speak(self):
        pass

# 具体产品
class cat(animal):
    def speak(self):
        print('Cat!')

class dog(animal):
    def speak(self):
        print('Dog!')

# 工厂的具体实现
class Animal_factory:
    @staticmethod
    def produce_animals(animal_type):
        if animal_type == 'cat':
            return cat()
        elif animal_type == 'dog':
            return dog()
        else:
            print('Invalid animal type')

if __name__ == '__main__':
	
	#创建工厂对象
    factory = Animal_factory()

    cat = factory.produce_animals('cat')
    dog = factory.produce_animals('dog')
    cat.speak()
    dog.speak()
```

简单工厂模式在Anima_factory的设计上存在局限，在开闭原则、可维护两个方面的处理较差。

案例2：工厂方法模式

```python
from abc import ABC, abstractmethod

# 创建产品接口
class Product(ABC):
    @abstractmethod
    def render(self):
        pass

    @abstractmethod
    def online_bottom(self):
        pass

# 创建具体产品
class Windows_buttom(Product):
    def render(self):
        return "渲染windows按钮！"
    def online_bottom(self):
        # 创建事件
        return "windows按钮被点击！"

class Linux_buttom(Product):
    def render(self):
        return "渲染Linux按钮"
    def online_bottom(self):
        return "linux按钮被点击"

# 创建工厂类
class Factory(ABC):
    @abstractmethod
    def create_product(self)->Product:
        pass
    def render(self):
        # 调用工厂方法来创建对象
        product = self.create_product()
        return product.render()

# 创建具体工厂
class Windows_factory(Factory):
    def create_product(self)->Product:
        return Windows_buttom()

class Linux_factory(Factory):
    def create_product(self)->Product:
        return Linux_buttom()

if __name__ == '__main__':
    config = 'windows'

    if config == 'windows':
        product = Windows_factory()
    elif config == 'linux':
        product = Linux_factory()

    print(product.render())
```
与简单工厂不同，工厂方法模式通过创建一个工厂类，并实现工厂内部的方法来创建产品对象，进一步降低了维护成本和推进开闭原则。但是实现还可以进一步抽象化，因为目前仅仅只能支持单一的产品族

案例3：抽象工厂模式
```python
from abc import ABC, abstractmethod

# TODO:创建不同功能接口
class Button(ABC):
    @abstractmethod
    def render(self):
        pass

class Checkbox(ABC):
    @abstractmethod
    def render(self):
        pass
# TODO:创建具体产品实现
class Windows_button(Button):
    def render(self):
        return "Windows Button!"

class Linux_button(Button):
    def render(self):
        return "Linux Button!"

class Windows_checkbox(Checkbox):
    def render(self):
        return "Windows Checkbox!"

class Linux_checkbox(Checkbox):
    def render(self):
        return "Linux Checkbox!"
# TODO:创建不同工厂接口
class Factory(ABC):
    @abstractmethod
    def create_button(self):
        pass
    @abstractmethod
    def create_checkbox(self):
        pass

# TODO:创建Windows和Linux具体的工厂
class Windows_factory(Factory):
    def create_button(self):
        return Windows_button()

    def create_checkbox(self):
        return Windows_checkbox()

class Linux_factory(Factory):
    def create_button(self):
        return Linux_button()
    def create_checkbox(self):
        return Linux_checkbox()

# TODO:创建与工厂交互的客户端
class Client:
    def __init__(self,factory:Factory) -> None:
        self.factory = factory
        self.button = None
        self.checkbox = None
    def create_UI(self):
        self.button = self.factory.create_button()
        self.checkbox = self.factory.create_checkbox()
    def render(self):
        render_list = []
        render_list.append(self.button.render())
        render_list.append(self.checkbox.render())
        return "".join(render_list)

if __name__ == "__main__":
    config = 'Windows'
    if config == 'Windows':
        factory = Windows_factory()
    elif config == 'Linux':
        factory = Linux_factory()

    product = Client(factory)
    product.create_UI()
    print(product.render())
```
抽象工厂模式将工厂类完全抽象出来，并由Client客户端来进行对象的创建，从而可以支持多个相关的产品族

三者区别总结：
简单工厂：复杂度低，适用范围小，违反开闭原则，依赖具体工厂类
工厂方法：复杂度高，适用于单一产品族，保持开闭原则，依赖抽象类
抽象工厂：复杂度很高，适用于多个相关产品族，保持开闭原则，依赖抽象接口
